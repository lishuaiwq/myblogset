---
title: 并查集
date: 2018-05-17 07:12:24
tags:
categories: 数据结构随笔
---
# 引入

- 首先我们来看一道题

> 假如已知有n个人和m对好友关系（存于数字r）。如果两个人是直接或间接的好友（好友的好友的好友...），则认为他们属于同一个朋友圈，请写程序求出这n个人里一共有多少个朋友圈。 假如：{% raw %}n = 5，m = 3，r = {{1 , 2} , {2 , 3} , {4 , 5}}{% endraw %}，表示有5个人，1和2是好友，2和3是好友，4和5是好友，则1、2、3属于一个朋友圈，4、5属于另一个朋友圈，结果为2个朋友圈。 最后请分析所写代码的时间、空间复杂度。评分会参考代码的正确性和效率。 C/C++： int friends(int n , int m , int* r[]);

## 问题分析

- 解决方法1

> 使用set，有初始数据有几个圈子则创建几个set，然后分别用一个set中的元素在其他set中找，找到了证明有共同的朋友，则合并这两个set，最后判断有几个set不为空就得出有几个朋友圈的结果。

- 解决方法2

> 使用位图，分别将每个朋友圈映射到位图中，然后两个分别&，如果&后有1存在的话，那么就有交集，则将两个位图|起来就可以了

- 解决方法3 `前两种方法都不是最好的，第三种就是我们引入的并查集`

# 并查集概念

- 在这里我就不按照那就标准的定义来了，我直接按照自己的理解去讲了。


## 并查集的作用

> 其实就是将你已知的集合中元素之间的关系，去建立并查集（建立的过程就是合并有关联的集合），在这个并查集中我们可以很方便的统计出一共有多少个集合。

- 就是用来求两个集合的并集的。

## 并查集建立过程
  
- 举个例子:

  > 有集合{0,1,2},{2,3,5},{4,6},{7,8},现在如何建立并查集

1. 一共有n元素则建立n+1个容量的并查集（重复的不算，如果编号不标准，则自己 按照他们的关系去编号,这里尽量从0开始，并且是连续的编号），所以在这里建立9个容量的并查集数据结构，并将其初始化为-1，这是为了方便我们后面的统计
![](https://i.imgur.com/IL21RAz.jpg)

2. 最开始肯定是两个元素去合并，那么选取一个作为表示其老大，用来保存他们这个集合中的元素的个数，这个老大的下标就是这个集合的标号，属于这个集合的元素的值就是这个老大的下标。

- 由例子集合的关系，我们的集合是这样建立的
  - （0,1）（1,2）（2,3）（3,5）（4,6）（6,7）
  - (0,1)我们首先判断0,1是否是一个老大如果是则说明是一个集合的，不用合并，如果不是则合并，这里的合并就是选取0作为合并后集合的老大，里面存的就是0,1合并后集合的大小即为2，那么下标为1的位置的值就是0，表示自己的老大是0，后面所有的合并都是重复这个过程。则合并完就是这个样子
  
 ![](https://i.imgur.com/sJiPbtg.jpg)
 
> 当我们判断上述集合可以合并为几个集合的时候，直接遍历数组，有几个位置的值小于0，则有几个集合。

---
> 上述的例子主要是针对于并查集的应用来讲的。

# 并查集的代码实现

```c++
#pragma once

#include<iostream>
#include<vector>
using namespace std;

class UFS 
{
private:
	vector<int> _set;
public:
	UFS(int size)//一共有多少个元素开辟多少个空间
		:_set(size, -1){}
	int Find(int x)//查找根
	{
		while (_set[x] >= 0)
		{
			x = _set[x];
		}
		return x;//一旦小于0直接返回去就是根
	}
	void Union(int x1, int x2)//合并两个元素
	{
		//首先找到两个元素的根
		int root1 = Find(x1);
		int root2 = Find(x2);

		if (root1 != root2)
		{
			_set[root1] += _set[root2];//将两个集合的元素总数加起来给集合1
			_set[root2] = root1;//集合2的根也属于集合1了
		}
	}
	int SetCount()//统计元素
	{
		int count = 0;
		for (size_t i = 0; i < _set.size(); ++i)
		{
			if (_set[i] < 0)
				++count;
		}
		return count;
	}
};

void Test()
{
	UFS u(6);
	
	cout << u.SetCount() << endl;//得到的结果在-1，因为没有0号元素
}
```
